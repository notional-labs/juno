// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/pegasus/go/pkg/mod/github.com/!cosm!wasm/wasmvm@v1.0.0-soon2.0.20211209162446-b96c92d21aaf/api/callbacks.go:1:1
package api

// Check https://akrennmair.github.io/golang-cgo-slides/ to learn
// how this embedded C code works.

/*
#include "bindings.h"

// typedefs for _cgo functions (db)
typedef GoResult (*read_db_fn)(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, UnmanagedVector *val, UnmanagedVector *errOut);
typedef GoResult (*write_db_fn)(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, U8SliceView val, UnmanagedVector *errOut);
typedef GoResult (*remove_db_fn)(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, UnmanagedVector *errOut);
typedef GoResult (*scan_db_fn)(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView start, U8SliceView end, int32_t order, GoIter *out, UnmanagedVector *errOut);
// iterator
typedef GoResult (*next_db_fn)(iterator_t idx, gas_meter_t *gas_meter, uint64_t *used_gas, UnmanagedVector *key, UnmanagedVector *val, UnmanagedVector *errOut);
// and api
typedef GoResult (*humanize_address_fn)(api_t *ptr, U8SliceView src, UnmanagedVector *dest, UnmanagedVector *errOut, uint64_t *used_gas);
typedef GoResult (*canonicalize_address_fn)(api_t *ptr, U8SliceView src, UnmanagedVector *dest, UnmanagedVector *errOut, uint64_t *used_gas);
typedef GoResult (*query_external_fn)(querier_t *ptr, uint64_t gas_limit, uint64_t *used_gas, U8SliceView request, UnmanagedVector *result, UnmanagedVector *errOut);

// forward declarations (db)
GoResult cGet_cgo(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, UnmanagedVector *val, UnmanagedVector *errOut);
GoResult cSet_cgo(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, U8SliceView val, UnmanagedVector *errOut);
GoResult cDelete_cgo(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView key, UnmanagedVector *errOut);
GoResult cScan_cgo(db_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, U8SliceView start, U8SliceView end, int32_t order, GoIter *out, UnmanagedVector *errOut);
// iterator
GoResult cNext_cgo(iterator_t *ptr, gas_meter_t *gas_meter, uint64_t *used_gas, UnmanagedVector *key, UnmanagedVector *val, UnmanagedVector *errOut);
// api
GoResult cHumanAddress_cgo(api_t *ptr, U8SliceView src, UnmanagedVector *dest, UnmanagedVector *errOut, uint64_t *used_gas);
GoResult cCanonicalAddress_cgo(api_t *ptr, U8SliceView src, UnmanagedVector *dest, UnmanagedVector *errOut, uint64_t *used_gas);
// and querier
GoResult cQueryExternal_cgo(querier_t *ptr, uint64_t gas_limit, uint64_t *used_gas, U8SliceView request, UnmanagedVector *result, UnmanagedVector *errOut);


*/
import _ "unsafe"

import (
	"encoding/json"
	"fmt"
	"log"
	"reflect"
	"runtime/debug"
	"unsafe"

	dbm "github.com/tendermint/tm-db"

	"github.com/CosmWasm/wasmvm/types"
)

// Note: we have to include all exports in the same file (at least since they both import bindings.h),
// or get odd cgo build errors about duplicate definitions

func recoverPanic(ret * /*line :54:24*/_Ctype_GoResult /*line :54:34*/) {
	if rec := recover(); rec != nil {
		// we don't want to import cosmos-sdk
		// we also cannot use interfaces to detect these error types (as they have no methods)
		// so, let's just rely on the descriptive names
		// this is used to detect "out of gas panics"
		name := reflect.TypeOf(rec).Name()
		switch name {
		// These two cases are for types thrown in panics from this module:
		// https://github.com/cosmos/cosmos-sdk/blob/4ffabb65a5c07dbb7010da397535d10927d298c1/store/types/gas.go
		// ErrorOutOfGas needs to be propagated through the rust code and back into go code, where it should
		// probably be thrown in a panic again.
		// TODO figure out how to pass the text in its `Descriptor` field through all the FFI
		// TODO handle these cases on the Rust side in the first place
		case "ErrorOutOfGas":
			*ret = ( /*line :69:11*/_Ciconst_GoResult_OutOfGas /*line :69:29*/)
		// Looks like this error is not treated specially upstream:
		// https://github.com/cosmos/cosmos-sdk/blob/4ffabb65a5c07dbb7010da397535d10927d298c1/baseapp/baseapp.go#L818-L853
		// but this needs to be periodically verified, in case they do start checking for this type
		// 	case "ErrorGasOverflow":
		default:
			log.Printf("Panic in Go callback: %#v\n", rec)
			debug.PrintStack()
			*ret = ( /*line :77:11*/_Ciconst_GoResult_Panic /*line :77:26*/)
		}
	}
}

type Gas = uint64

// GasMeter is a copy of an interface declaration from cosmos-sdk
// https://github.com/cosmos/cosmos-sdk/blob/18890a225b46260a9adc587be6fa1cc2aff101cd/store/types/gas.go#L34
type GasMeter interface {
	GasConsumed() Gas
}

/****** DB ********/

// KVStore copies a subset of types from cosmos-sdk
// We may wish to make this more generic sometime in the future, but not now
// https://github.com/cosmos/cosmos-sdk/blob/bef3689245bab591d7d169abd6bea52db97a70c7/store/types/store.go#L170
type KVStore interface {
	Get(key []byte) []byte
	Set(key, value []byte)
	Delete(key []byte)

	// Iterator over a domain of keys in ascending order. End is exclusive.
	// Start must be less than end, or the Iterator is invalid.
	// Iterator must be closed by caller.
	// To iterate over entire domain, use store.Iterator(nil, nil)
	Iterator(start, end []byte) dbm.Iterator

	// Iterator over a domain of keys in descending order. End is exclusive.
	// Start must be less than end, or the Iterator is invalid.
	// Iterator must be closed by caller.
	ReverseIterator(start, end []byte) dbm.Iterator
}

var db_vtable =  /*line :112:17*/_Ctype_Db_vtable /*line :112:28*/{
	read_db:   ( /*line :113:14*/_Ctype_read_db_fn /*line :113:26*/)(( /*line :113:28*/_Cgo_ptr(_Cfpvar_fp_cGet_cgo) /*line :113:37*/)),
	write_db:  ( /*line :114:14*/_Ctype_write_db_fn /*line :114:27*/)(( /*line :114:29*/_Cgo_ptr(_Cfpvar_fp_cSet_cgo) /*line :114:38*/)),
	remove_db: ( /*line :115:14*/_Ctype_remove_db_fn /*line :115:28*/)(( /*line :115:30*/_Cgo_ptr(_Cfpvar_fp_cDelete_cgo) /*line :115:42*/)),
	scan_db:   ( /*line :116:14*/_Ctype_scan_db_fn /*line :116:26*/)(( /*line :116:28*/_Cgo_ptr(_Cfpvar_fp_cScan_cgo) /*line :116:38*/)),
}

type DBState struct {
	Store KVStore
	// IteratorStackID is used to lookup the proper stack frame for iterators associated with this DB (iterator.go)
	IteratorStackID uint64
}

// use this to create C.Db in two steps, so the pointer lives as long as the calling stack
//   state := buildDBState(kv, counter)
//   db := buildDB(&state, &gasMeter)
//   // then pass db into some FFI function
func buildDBState(kv KVStore, counter uint64) DBState {
	return DBState{
		Store:           kv,
		IteratorStackID: counter,
	}
}

// contract: original pointer/struct referenced must live longer than C.Db struct
// since this is only used internally, we can verify the code that this is the case
func buildDB(state *DBState, gm *GasMeter)  /*line :138:44*/_Ctype_Db /*line :138:48*/ {
	return  /*line :139:9*/_Ctype_Db /*line :139:13*/{
		gas_meter: (* /*line :140:16*/_Ctype_gas_meter_t /*line :140:29*/)(unsafe.Pointer(gm)),
		state:     (* /*line :141:16*/_Ctype_db_t /*line :141:22*/)(unsafe.Pointer(state)),
		vtable:    db_vtable,
	}
}

var iterator_vtable =  /*line :146:23*/_Ctype_Iterator_vtable /*line :146:40*/{
	next_db: ( /*line :147:12*/_Ctype_next_db_fn /*line :147:24*/)(( /*line :147:26*/_Cgo_ptr(_Cfpvar_fp_cNext_cgo) /*line :147:36*/)),
}

// contract: original pointer/struct referenced must live longer than C.Db struct
// since this is only used internally, we can verify the code that this is the case
func buildIterator(dbCounter uint64, it dbm.Iterator)  /*line :152:55*/_Ctype_iterator_t /*line :152:67*/ {
	idx := storeIterator(dbCounter, it)
	return  /*line :154:9*/_Ctype_iterator_t /*line :154:21*/{
		db_counter:     cu64(dbCounter),
		iterator_index: cu64(idx),
	}
}

//export cGet
func cGet(ptr * /*line :161:16*/_Ctype_db_t /*line :161:22*/, gasMeter * /*line :161:34*/_Ctype_gas_meter_t /*line :161:47*/, usedGas *cu64, key  /*line :161:68*/_Ctype_U8SliceView /*line :161:81*/, val * /*line :161:88*/_Ctype_UnmanagedVector /*line :161:105*/, errOut * /*line :161:115*/_Ctype_UnmanagedVector /*line :161:132*/) (ret  /*line :161:139*/_Ctype_GoResult /*line :161:149*/) {
	defer recoverPanic(&ret)

	if ptr == nil || gasMeter == nil || usedGas == nil || val == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :166:10*/_Ciconst_GoResult_BadArgument /*line :166:31*/)
	}
	if !(*val).is_none || !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	gm := *(*GasMeter)(unsafe.Pointer(gasMeter))
	kv := *(*KVStore)(unsafe.Pointer(ptr))
	k := copyU8Slice(key)

	gasBefore := gm.GasConsumed()
	v := kv.Get(k)
	gasAfter := gm.GasConsumed()
	*usedGas = (cu64)(gasAfter - gasBefore)

	// v will equal nil when the key is missing
	// https://github.com/cosmos/cosmos-sdk/blob/1083fa948e347135861f88e07ec76b0314296832/store/types/store.go#L174
	*val = newUnmanagedVector(v)

	return ( /*line :185:9*/_Ciconst_GoResult_Ok /*line :185:21*/)
}

//export cSet
func cSet(ptr * /*line :189:16*/_Ctype_db_t /*line :189:22*/, gasMeter * /*line :189:34*/_Ctype_gas_meter_t /*line :189:47*/, usedGas * /*line :189:58*/_Ctype_uint64_t /*line :189:68*/, key  /*line :189:74*/_Ctype_U8SliceView /*line :189:87*/, val  /*line :189:93*/_Ctype_U8SliceView /*line :189:106*/, errOut * /*line :189:116*/_Ctype_UnmanagedVector /*line :189:133*/) (ret  /*line :189:140*/_Ctype_GoResult /*line :189:150*/) {
	defer recoverPanic(&ret)

	if ptr == nil || gasMeter == nil || usedGas == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :194:10*/_Ciconst_GoResult_BadArgument /*line :194:31*/)
	}
	if !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	gm := *(*GasMeter)(unsafe.Pointer(gasMeter))
	kv := *(*KVStore)(unsafe.Pointer(ptr))
	k := copyU8Slice(key)
	v := copyU8Slice(val)

	gasBefore := gm.GasConsumed()
	kv.Set(k, v)
	gasAfter := gm.GasConsumed()
	*usedGas = ( /*line :208:14*/_Ctype_uint64_t /*line :208:24*/)(gasAfter - gasBefore)

	return ( /*line :210:9*/_Ciconst_GoResult_Ok /*line :210:21*/)
}

//export cDelete
func cDelete(ptr * /*line :214:19*/_Ctype_db_t /*line :214:25*/, gasMeter * /*line :214:37*/_Ctype_gas_meter_t /*line :214:50*/, usedGas * /*line :214:61*/_Ctype_uint64_t /*line :214:71*/, key  /*line :214:77*/_Ctype_U8SliceView /*line :214:90*/, errOut * /*line :214:100*/_Ctype_UnmanagedVector /*line :214:117*/) (ret  /*line :214:124*/_Ctype_GoResult /*line :214:134*/) {
	defer recoverPanic(&ret)

	if ptr == nil || gasMeter == nil || usedGas == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :219:10*/_Ciconst_GoResult_BadArgument /*line :219:31*/)
	}
	if !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	gm := *(*GasMeter)(unsafe.Pointer(gasMeter))
	kv := *(*KVStore)(unsafe.Pointer(ptr))
	k := copyU8Slice(key)

	gasBefore := gm.GasConsumed()
	kv.Delete(k)
	gasAfter := gm.GasConsumed()
	*usedGas = ( /*line :232:14*/_Ctype_uint64_t /*line :232:24*/)(gasAfter - gasBefore)

	return ( /*line :234:9*/_Ciconst_GoResult_Ok /*line :234:21*/)
}

//export cScan
func cScan(ptr * /*line :238:17*/_Ctype_db_t /*line :238:23*/, gasMeter * /*line :238:35*/_Ctype_gas_meter_t /*line :238:48*/, usedGas * /*line :238:59*/_Ctype_uint64_t /*line :238:69*/, start  /*line :238:77*/_Ctype_U8SliceView /*line :238:90*/, end  /*line :238:96*/_Ctype_U8SliceView /*line :238:109*/, order ci32, out * /*line :238:128*/_Ctype_GoIter /*line :238:136*/, errOut * /*line :238:146*/_Ctype_UnmanagedVector /*line :238:163*/) (ret  /*line :238:170*/_Ctype_GoResult /*line :238:180*/) {
	defer recoverPanic(&ret)

	if ptr == nil || gasMeter == nil || usedGas == nil || out == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :243:10*/_Ciconst_GoResult_BadArgument /*line :243:31*/)
	}
	if !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	gm := *(*GasMeter)(unsafe.Pointer(gasMeter))
	state := (*DBState)(unsafe.Pointer(ptr))
	kv := state.Store
	s := copyU8Slice(start)
	e := copyU8Slice(end)

	var iter dbm.Iterator
	gasBefore := gm.GasConsumed()
	switch order {
	case 1: // Ascending
		iter = kv.Iterator(s, e)
	case 2: // Descending
		iter = kv.ReverseIterator(s, e)
	default:
		return ( /*line :263:10*/_Ciconst_GoResult_BadArgument /*line :263:31*/)
	}
	gasAfter := gm.GasConsumed()
	*usedGas = ( /*line :266:14*/_Ctype_uint64_t /*line :266:24*/)(gasAfter - gasBefore)

	out.state = buildIterator(state.IteratorStackID, iter)
	out.vtable = iterator_vtable
	return ( /*line :270:9*/_Ciconst_GoResult_Ok /*line :270:21*/)
}

//export cNext
func cNext(ref  /*line :274:16*/_Ctype_iterator_t /*line :274:28*/, gasMeter * /*line :274:40*/_Ctype_gas_meter_t /*line :274:53*/, usedGas * /*line :274:64*/_Ctype_uint64_t /*line :274:74*/, key * /*line :274:81*/_Ctype_UnmanagedVector /*line :274:98*/, val * /*line :274:105*/_Ctype_UnmanagedVector /*line :274:122*/, errOut * /*line :274:132*/_Ctype_UnmanagedVector /*line :274:149*/) (ret  /*line :274:156*/_Ctype_GoResult /*line :274:166*/) {
	// typical usage of iterator
	// 	for ; itr.Valid(); itr.Next() {
	// 		k, v := itr.Key(); itr.Value()
	// 		...
	// 	}

	defer recoverPanic(&ret)
	if ref.db_counter == 0 || gasMeter == nil || usedGas == nil || key == nil || val == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :284:10*/_Ciconst_GoResult_BadArgument /*line :284:31*/)
	}
	if !(*key).is_none || !(*val).is_none || !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	gm := *(*GasMeter)(unsafe.Pointer(gasMeter))
	iter := retrieveIterator(uint64(ref.db_counter), uint64(ref.iterator_index))
	if !iter.Valid() {
		// end of iterator, return as no-op, nil key is considered end
		return ( /*line :294:10*/_Ciconst_GoResult_Ok /*line :294:22*/)
	}

	gasBefore := gm.GasConsumed()
	// call Next at the end, upon creation we have first data loaded
	k := iter.Key()
	v := iter.Value()
	// check iter.Error() ????
	iter.Next()
	gasAfter := gm.GasConsumed()
	*usedGas = ( /*line :304:14*/_Ctype_uint64_t /*line :304:24*/)(gasAfter - gasBefore)

	*key = newUnmanagedVector(k)
	*val = newUnmanagedVector(v)
	return ( /*line :308:9*/_Ciconst_GoResult_Ok /*line :308:21*/)
}

/***** GoAPI *******/

type HumanizeAddress func([]byte) (string, uint64, error)
type CanonicalizeAddress func(string) ([]byte, uint64, error)

type GoAPI struct {
	HumanAddress     HumanizeAddress
	CanonicalAddress CanonicalizeAddress
}

var api_vtable =  /*line :321:18*/_Ctype_GoApi_vtable /*line :321:32*/{
	humanize_address:     ( /*line :322:25*/_Ctype_humanize_address_fn /*line :322:46*/)(( /*line :322:48*/_Cgo_ptr(_Cfpvar_fp_cHumanAddress_cgo) /*line :322:66*/)),
	canonicalize_address: ( /*line :323:25*/_Ctype_canonicalize_address_fn /*line :323:50*/)(( /*line :323:52*/_Cgo_ptr(_Cfpvar_fp_cCanonicalAddress_cgo) /*line :323:74*/)),
}

// contract: original pointer/struct referenced must live longer than C.GoApi struct
// since this is only used internally, we can verify the code that this is the case
func buildAPI(api *GoAPI)  /*line :328:27*/_Ctype_GoApi /*line :328:34*/ {
	return  /*line :329:9*/_Ctype_GoApi /*line :329:16*/{
		state:  (* /*line :330:13*/_Ctype_api_t /*line :330:20*/)(unsafe.Pointer(api)),
		vtable: api_vtable,
	}
}

//export cHumanAddress
func cHumanAddress(ptr * /*line :336:25*/_Ctype_api_t /*line :336:32*/, src  /*line :336:38*/_Ctype_U8SliceView /*line :336:51*/, dest * /*line :336:59*/_Ctype_UnmanagedVector /*line :336:76*/, errOut * /*line :336:86*/_Ctype_UnmanagedVector /*line :336:103*/, used_gas *cu64) (ret  /*line :336:126*/_Ctype_GoResult /*line :336:136*/) {
	defer recoverPanic(&ret)

	if dest == nil || errOut == nil {
		return ( /*line :340:10*/_Ciconst_GoResult_BadArgument /*line :340:31*/)
	}
	if !(*dest).is_none || !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	api := (*GoAPI)(unsafe.Pointer(ptr))
	s := copyU8Slice(src)

	h, cost, err := api.HumanAddress(s)
	*used_gas = cu64(cost)
	if err != nil {
		// store the actual error message in the return buffer
		*errOut = newUnmanagedVector([]byte(err.Error()))
		return ( /*line :354:10*/_Ciconst_GoResult_User /*line :354:24*/)
	}
	if len(h) == 0 {
		panic(fmt.Sprintf("`api.HumanAddress()` returned an empty string for %q", s))
	}
	*dest = newUnmanagedVector([]byte(h))
	return ( /*line :360:9*/_Ciconst_GoResult_Ok /*line :360:21*/)
}

//export cCanonicalAddress
func cCanonicalAddress(ptr * /*line :364:29*/_Ctype_api_t /*line :364:36*/, src  /*line :364:42*/_Ctype_U8SliceView /*line :364:55*/, dest * /*line :364:63*/_Ctype_UnmanagedVector /*line :364:80*/, errOut * /*line :364:90*/_Ctype_UnmanagedVector /*line :364:107*/, used_gas *cu64) (ret  /*line :364:130*/_Ctype_GoResult /*line :364:140*/) {
	defer recoverPanic(&ret)

	if dest == nil || errOut == nil {
		return ( /*line :368:10*/_Ciconst_GoResult_BadArgument /*line :368:31*/)
	}
	if !(*dest).is_none || !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	api := (*GoAPI)(unsafe.Pointer(ptr))
	s := string(copyU8Slice(src))
	c, cost, err := api.CanonicalAddress(s)
	*used_gas = cu64(cost)
	if err != nil {
		// store the actual error message in the return buffer
		*errOut = newUnmanagedVector([]byte(err.Error()))
		return ( /*line :381:10*/_Ciconst_GoResult_User /*line :381:24*/)
	}
	if len(c) == 0 {
		panic(fmt.Sprintf("`api.CanonicalAddress()` returned an empty string for %q", s))
	}
	*dest = newUnmanagedVector(c)
	return ( /*line :387:9*/_Ciconst_GoResult_Ok /*line :387:21*/)
}

/****** Go Querier ********/

var querier_vtable =  /*line :392:22*/_Ctype_Querier_vtable /*line :392:38*/{
	query_external: ( /*line :393:19*/_Ctype_query_external_fn /*line :393:38*/)(( /*line :393:40*/_Cgo_ptr(_Cfpvar_fp_cQueryExternal_cgo) /*line :393:59*/)),
}

// contract: original pointer/struct referenced must live longer than C.GoQuerier struct
// since this is only used internally, we can verify the code that this is the case
func buildQuerier(q *Querier)  /*line :398:31*/_Ctype_GoQuerier /*line :398:42*/ {
	return  /*line :399:9*/_Ctype_GoQuerier /*line :399:20*/{
		state:  (* /*line :400:13*/_Ctype_querier_t /*line :400:24*/)(unsafe.Pointer(q)),
		vtable: querier_vtable,
	}
}

//export cQueryExternal
func cQueryExternal(ptr * /*line :406:26*/_Ctype_querier_t /*line :406:37*/, gasLimit  /*line :406:48*/_Ctype_uint64_t /*line :406:58*/, usedGas * /*line :406:69*/_Ctype_uint64_t /*line :406:79*/, request  /*line :406:89*/_Ctype_U8SliceView /*line :406:102*/, result * /*line :406:112*/_Ctype_UnmanagedVector /*line :406:129*/, errOut * /*line :406:139*/_Ctype_UnmanagedVector /*line :406:156*/) (ret  /*line :406:163*/_Ctype_GoResult /*line :406:173*/) {
	defer recoverPanic(&ret)

	if ptr == nil || usedGas == nil || result == nil || errOut == nil {
		// we received an invalid pointer
		return ( /*line :411:10*/_Ciconst_GoResult_BadArgument /*line :411:31*/)
	}
	if !(*result).is_none || !(*errOut).is_none {
		panic("Got a non-none UnmanagedVector we're about to override. This is a bug because someone has to drop the old one.")
	}

	// query the data
	querier := *(*Querier)(unsafe.Pointer(ptr))
	req := copyU8Slice(request)

	gasBefore := querier.GasConsumed()
	res := types.RustQuery(querier, req, uint64(gasLimit))
	gasAfter := querier.GasConsumed()
	*usedGas = ( /*line :424:14*/_Ctype_uint64_t /*line :424:24*/)(gasAfter - gasBefore)

	// serialize the response
	bz, err := json.Marshal(res)
	if err != nil {
		*errOut = newUnmanagedVector([]byte(err.Error()))
		return ( /*line :430:10*/_Ciconst_GoResult_Other /*line :430:25*/)
	}
	*result = newUnmanagedVector(bz)
	return ( /*line :433:9*/_Ciconst_GoResult_Ok /*line :433:21*/)
}
